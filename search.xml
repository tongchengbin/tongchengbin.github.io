<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F21%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gogs与主机共享22端口]]></title>
    <url>%2F2018%2F03%2F10%2FDocker-Gogs%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%85%B1%E4%BA%AB22%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[在使用Docker安装Gogs时，一般会把容器的22端口映射到主机的其它端口(比如10022)在以SSH方式clone项目时，URL长这样 ssh://git@git.example.com:10022:username/project.git 但我们想要的是类似于GitHub那样的，这时需要把Gogs的SSH端口设置为22 git@git.example.com:username/project.git 下面说一下主要步骤 创建git用户123456[root]$ useradd git[root]$ id git # 获取uid和giduid=1002(git) gid=1002(git) groups=1002(git)[root]$ usermod -aG docker git # 把git用户加入docker组[root]$ su git[git]$ mkdir -p ~/gogs/data # 在git用户下创建gogs/data文件夹，作为gogs容器主要数据的挂载目录 安装Gogs12[git]$ docker run -d --name=gogs -p 10022:22 -p 10080:3000 -v ~/gogs/data:/data -e "PUID=1002" -e "PGID=1002" --restart=always gogs/gogs # PUID PGID与上面获取的uid gid保持一致[git]$ ln -s ~/gogs/data/git/.ssh ~/ # 将gogs的.ssh目录软连接到本地的.ssh 现在可以通过服务器外网ip:10080进入安装页面，也可以等反代设置好后通过域名进行访问我用的数据库是Sqlite3，不需要额外配置，如果你选择的是其它数据库，可以参考这篇文章相关配置可以参考官方文档 生成SSH key1234[git]$ ssh-keygen -t rsa -b 4096 -C "git@git.example.com"[git]$ cd ~/.ssh[git]$ cat id_rsa.pub &gt;&gt; authorized_keys[git]$ chmod 600 authorized_keys 在authorized_keys最前面添加 1no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa AAAAB3NzaC1y..........YGedddqAN6w== git@git.example.com Caddy反向代理1[root]$ mkdir caddy &amp;&amp; cd $_ 在caddy目录下创建Caddyfile文件，下面是参考配置 123456git.example.com &#123; tls git@example.com # 填写你的邮箱，用于申请证书 proxy / your-ip:10080 header / Strict-Transport-Security &quot;max-age=31536000;&quot; # 开启HSTS gzip&#125; 启动caddy1[root]$ docker run -d --name=caddy -v ~/caddy/Caddyfile:/etc/Caddyfile -v ~/.caddy:/root/.caddy -p 80:80 -p 443:443 --restart=always abiosoft/caddy 配置git用户登录问题1234567[root]$ mkdir -p /app/gogs/[root]$ cat &gt;/app/gogs/gogs &lt;&lt;'END'#!/bin/shssh -p 10022 -o StrictHostKeyChecking=no git@127.0.0.1 \"SSH_ORIGINAL_COMMAND=\"$SSH_ORIGINAL_COMMAND\" $0 $@"END[root]$ chmod 755 /app/gogs/gogs 这样就差不多完成了，下面需要在本地生成SSH密匙，然后在web端把密匙添加到Gogs如果需要修改Gogs的配置，比如安装的时候DOMAIN写的IP现在要修改为域名，可以到/home/git/gogs/data/gogs/conf/找到app.ini，修改完后重启gogs容器 参考文章安装Gogs并共享主机22端口Share port 22 between Gogs inside Docker &amp; the local system]]></content>
      <tags>
        <tag>Gogs</tag>
        <tag>Git</tag>
        <tag>SSH</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题优化：重构leancloud阅读量统计模块]]></title>
    <url>%2F2018%2F02%2F11%2FNexT%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%EF%BC%9A%E9%87%8D%E6%9E%84leancloud%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[为什么要重构从去年 10 月份开始，LeanCloud 国内节点 API 的老版域名 api.leancloud.cn 在国外一些地区和国内少数地区会出现一定概率的解析错误（DNS 污染），这导致我们的博客阅读量无法正常显示 官方解决方案如果使用的是原生 SDK，请尽快升级到以下版本： Android 3.16.4 及更高版本 iOS 5.0.0 及更高版本 JavaScript 3.0.0 及更高版本 如果使用 REST API 来访问 api.leancloud.cn，请通过以下地址来动态获取应用专属的二级域名： https://app-router.leancloud.cn/2/route?appId= &lt;替换为 appId&gt; 然后使用 api_server 指示的域名来访问我们的 API 服务，即可正常获得结果。 NexT 主题里使用的 SDK 是 av-core-mini-0.6.4，这个库 gzip 后有 28.5KB对于一个只有几个请求的小模块来说，完全没必要用 SDK，可以手动请求官方 API 完成目的 重构后的代码可以到我的GitHub查看]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>NexT</tag>
        <tag>Leancloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新版知乎模拟登陆]]></title>
    <url>%2F2018%2F02%2F10%2F%E6%96%B0%E7%89%88%E7%9F%A5%E4%B9%8E%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[概述在群里经常看到有人问知乎的登录方式,记得以前写过模拟登陆的案例,但是由于改版的原因已经失效了 从新看了一下知乎登录的流程 对于新手来说确实有一定的难度，主要是分析js的加密方法,对于js渣渣来说简直就是噩梦。 流程分析输入一个错误的密码 查看请求因为知乎登录教程比较多 这里着重看登录请求 captcha没啥好说的从request headers中我们可以找到请求头 当然还有很重要的一个参数authorization:oauth c3cef7c66a1843f8b3a9e6a1e3160e20我们打开一个隐身窗口 输入不同的账户再次模拟 发现这个参数的是不变的 那就不用去探究他的由来 直接用最重要的是payload部分增加了新的 参数 可能看起来怪怪的 跟以前看到的payload 不一样 但是还是很用容易发现规律 去掉 “——WebKitFormBoundarygbNkZ3Q6sZBpmPVk” 提取nameclient_id=c3cef7c66a1843f8b3a9e6a1e3160e20得到了这种格式因此我们就知道我们需要提交哪一些参数了{client_idgrant_typetimestampsourcesignatureusernamepasswordcaptchalangref_sourceutm_source}比较两次模拟 发现除了signature是变化了 cliient_id就是authorization中的一部分 timestamp有经验的人一看就知道是时间戳 大部分的人也是到这里就不知道怎么办了 signature在html中找不到 那么肯定在js中 我们去js中搜索关键字”signature” 最后定位到了https://static.zhihu.com/heifetz/main.app.7bfdc6cca34029fdef12.![](http://ozelrebbz.bkt.clouddn.com/9d70f2b6c14c91b386f3a24031005fd4.png)因为文件比较大 我们拷贝到编辑器中 这里推荐一波sublime text 同时使用js format插件格式化(百度),当然也可以在线格式化这个是signature相关函数 到这里我们基本可以猜测出他的加密方式了hmacHMAC 是用于消息认证的加密哈希算法，全称是 keyed-Hash Message Authentication Code。HMAC 利用哈希算法，以一个密钥和一个消息作为输入，生成一个加密串作为输出。HMAC 可以有效防止类似 MD5 的彩虹表等攻击，比如将常见密码的 MD5 值存入数据库，可能被反向破解。Python 的 hmac 模块提供了 HMAC 算法，它的使用形式是：1hmac.new(key[, msg[, digestmod]]) 其中，key 是一个密钥；msg 是消息，可选，如果给出 msg，则调用方法 update(msg)；digestmod 是 HMAC 对象使用的摘要构造函数或模块，默认为 hashlib.md5 构造函数。m.update(a);m.update(b);相当于：m.update(a+b) HMAC.digest()返回目前传递给 update() 方法的字符串的摘要。此字符串长度将与给构造函数的摘要的 digest_size 相同。它可能包含非 ASCII 字符，包括 NULL 字节。 HMAC.hexdigest()类似 digest()，但是返回的摘要的字符串的长度翻倍，且只包含十六进制数字1234567891011&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; import hashlib&gt;&gt;&gt; import hmac&gt;&gt;&gt; key = &apos;you-never-know&apos;&gt;&gt;&gt; msg = datetime.utcnow().strftime(&apos;%Y-%m-%d&apos;)&gt;&gt;&gt; m = hmac.new(key, msg, hashlib.sha1)&gt;&gt;&gt; signature = m.hexdigest()&gt;&gt;&gt; signature&apos;fdb2087a66a2f00afbc1884738467ba089782779&apos; 那么加密参数有哪些呢？1 ‘d1b964811afb40118a12068ff74a12f4’2 e3 i.a4 ‘com.zhihu.web’5 n这里的e，i.a,n是啥 不知道 那么在来看下这个{ clientId: i.a, grantType: e, timestamp: n, source: “com.zhihu.web”, signature: r.getHMAC(“HEX”) }是不是很熟悉 没错 都是我们需要获取的参数 所以i.a就是cliendId，e就是字符串password,= Date.now() 这样加密的参数就齐了我们来测试一下跟js加密得到的signature是一样的。完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import requestsimport timeimport hmacimport osfrom hashlib import sha1import jsonfrom bs4 import BeautifulSoupsession=requests.session()def get_signature(st): key = &apos;d1b964811afb40118a12068ff74a12f4&apos; signature = hmac.new(key.encode(&apos;utf-8&apos;), &apos;&apos;.encode(&apos;utf-8&apos;), sha1) signature.update(&quot;password&quot;.encode(&apos;utf-8&apos;)) signature.update(&quot;c3cef7c66a1843f8b3a9e6a1e3160e20&quot;.encode(&apos;utf-8&apos;)) signature.update(&quot;com.zhihu.web&quot;.encode(&apos;utf-8&apos;)) signature.update(st.encode(&apos;utf-8&apos;)) signature.hexdigest() return signature.hexdigest()def is_login(account): &apos;&apos;&apos;自动检测本地是否有cookies文件 如果有文件 检测是否登录&apos;&apos;&apos; cf=&quot;cookies_&quot;+str(account) if os.path.exists(cf): cookie_dict=json.loads(open(cf,&apos;r&apos;).read()) session.cookies = requests.utils.cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True) r=session.get(&quot;https://www.zhihu.com/settings/profile&quot;,allow_redirects=False) if r.status_code==200: print(&quot;登录成功&quot;) soup=BeautifulSoup(r.text,&apos;html.parser&apos;) try: nickname=soup.find_all(class_=&quot;name&quot;)[0].text except: nickname = &quot;没有获取到昵称!&quot; print(&quot;hello &quot;+nickname) return True else: print(r.status_code) return False else: print(&quot;cookies不存在&quot;) return Falsedef zhihu_login(account,password): header = &#123; &apos;host&apos;: &apos;www.zhihu.com&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36&apos;, &apos;Referer&apos;: &apos;https://www.zhihu.com/&apos;, &apos;authorization&apos;: &apos;oauth c3cef7c66a1843f8b3a9e6a1e3160e20&apos; &#125; session.headers=header if is_login(account): return True captcha_url = &apos;https://www.zhihu.com/api/v3/oauth/captcha?lang=en&apos; response = session.get(captcha_url) show_captcha = json.loads(response.text)[&apos;show_captcha&apos;] if not show_captcha: captcha = &apos;&apos; else: img_resp=session.get(captcha_url) with open(&apos;captcha.jpg&apos;, &apos;wb&apos;) as f: f.write(img_resp.content) captcha = input(&quot;please input the captcha\n&gt;&quot;) st = str(int(time.time() * 1000)) form_data = &#123; &apos;client_id&apos;: &apos;c3cef7c66a1843f8b3a9e6a1e3160e20&apos;, &apos;grant_type&apos;: &apos;password&apos;, &apos;timestamp&apos;: st, &apos;source&apos;: &apos;com.zhihu.web&apos;, &apos;signature&apos;: get_signature(st), &apos;username&apos;: account, &apos;password&apos;: password, &apos;captcha&apos;: captcha, &apos;lang&apos;: &apos;cn&apos;, &apos;ref_source&apos;: &apos;homepage&apos;, &apos;utm_source&apos;: &apos;&apos;, &#125; login_url = &apos;https://www.zhihu.com/api/v3/oauth/sign_in&apos; result = session.post(login_url, data=form_data) login_json=json.loads(result.text) if &quot;access_token&quot; in login_json.keys(): print(&quot;登錄成功&quot;) #保存cookie cookies = requests.utils.dict_from_cookiejar(session.cookies) with open(&quot;cookies_&quot;+str(account),&apos;w&apos;) as f: f.write(json.dumps(cookies)) else: print(login_json)zhihu_login(&quot;你的用户&quot;,&quot;密码&quot;)]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>lodash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grub rescue模式下修复Linux引导]]></title>
    <url>%2F2017%2F11%2F22%2Fgrub-rescue%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BF%AE%E5%A4%8DLinux%E5%BC%95%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[前些天把很久没用的 Windows10 更新了下，更新后就进不了 Linux 系统了，提示 “file ‘/boot/grub/x86_64-efi/normal.mod’ not found”，之后就进入 grub rescue 模式了 解决方法很简单，在 grub rescue 模式下找到系统的启动分区，手动启动系统，之后重新安装 grub 到 efi 分区即可 grub rescue 下的操作12345678910# 查看设备和分区情况grub rescue&gt; ls(hd0) (hd0, gpt2) (hd0, gpt1) ...# 查看分区文件确定启动分区位置grub rescue&gt; ls (hd1, gpt10)/# 设置启动分区，载入启动需要的模块grub rescue&gt; set root=(hd1, gpt10)grub rescue&gt; set prefix=(hd1, gpt10)/boot/grubgrub rescue&gt; insmod normalgrub rescue&gt; normal 执行完 normal 命令后，顺利的话就能进入系统了 查找 boot/efi通过命令 df 查看 boot/efi 所在挂载点 重新安装 grub1➜ sudo grub-install /dev/sda1]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>grub</tag>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode icon 分享]]></title>
    <url>%2F2017%2F10%2F12%2FVSCode-icon-%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[Icon created for Visual Studio Code Reference iiroj/public DownloadRaincal/vscode-icon]]></content>
      <tags>
        <tag>Editor</tag>
        <tag>VSCode</tag>
        <tag>Icon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Docker部署FlarumChina]]></title>
    <url>%2F2017%2F08%2F07%2F%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2FlarumChina%2F</url>
    <content type="text"><![CDATA[前期准备服务器安装 Docker 和 Docker Compose 参考教程：http://get.daocloud.io/#install-docker 没有服务器的可以在本地安装 Docker 或使用 DaoCloud 的胶囊主机, 能免费体验 120 分钟，足够学习使用 路径：自有主机 -&gt; 集群管理 -&gt; 添加主机 安装 Flarum我们使用到的镜像是 raincal/docker-flarum-china Ports8888 Volume /flarum/app/assets : FlarumChina 资源目录 /flarum/app/extensions : FlarumChina 插件目录 环境变量 变量 描述 类型 默认值 UID Flarum user id optional 991 GID Flarum group id optional 991 DEBUG Flarum debug mode optional false FORUM_URL Forum URL required none DB_HOST MariaDB instance ip/hostname optional mariadb DB_USER MariaDB database username optional flarum DB_NAME MariaDB database name optional flarum DB_PASS MariaDB database password required none DB_PREF Flarum tables prefix optional none UPLOAD_MAX_SIZE The maximum size of an uploaded file optional 50M MEMORY_LIMIT maximum amount of memory used by php optional 128M 编写 docker-compose.yml 文件12mkdir flarum &amp;&amp; cd flarumvi docker-compose.yml 根据自身情况 修改 FORUM_URL DB_PASS MYSQL_ROOT_PASSWORD MYSQL_PASSWORD 等环境变量 123456789101112131415161718192021222324252627282930313233343536flarum: image: raincal/docker-flarum-china:0.1.0-beta.7-stable container_name: flarum links: - mariadb:mariadb environment: - FORUM_URL=https://forum.domain.tld - DB_PASS=123456 volumes: - /mnt/docker/flarum/assets:/flarum/app/assets - /mnt/docker/flarum/extensions:/flarum/app/extensionsmariadb: image: mariadb:10.1 container_name: mariadb volumes: - /mnt/docker/mysql/db:/var/lib/mysql environment: - MYSQL_ROOT_PASSWORD=123456 - MYSQL_DATABASE=flarum - MYSQL_USER=flarum - MYSQL_PASSWORD=123456nginx: image: wonderfall/boring-nginx container_name: nginx links: - flarum:flarum ports: - "80:8000" - "443:4430" volumes: - /mnt/docker/nginx/sites-enabled:/sites-enabled - /mnt/docker/nginx/conf:/conf.d - /mnt/docker/nginx/log:/var/log/nginx - /mnt/docker/nginx/certs:/certs 启动应用docker-compose up -d 若使用胶囊主机，可以到 自有主机 -&gt; Stack -&gt; 创建新 Stack 设置 nginx 反向代理通过 ssh 连接到胶囊主机 ssh ubuntu@52.80.37.119 12345678910111213141516docker exec -it nginx ngxproxyWelcome to ngxproxy utility.We're about to create a new virtual host (AKA server block).Name: flarumDomain: forum.domain.tldWebroot (default is /):Container: flarumPort (default is 80): 8888HTTPS [y/n]: nMax body size in MB (integer/null): 50Done! flarum.conf has been generated.Reload nginx now? [y/n]: ynginx successfully reloaded. 完成后访问外网IP 52.80.37.119，本地环境的话访问 localhost 开始安装 flarum 管理员密码需要大于8位]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDB常用命令]]></title>
    <url>%2F2015%2F07%2F10%2FmongoDB%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[安装mongoDB官网下载安装（Windows安装方法） 基础知识集合——对应关系数据库中的表 文档——对应关系数据库中的行 启动数据库服务定位到安装目录下的bin文件夹里后 &gt; mongod --dbpath ../data/db 如没有data/db文件夹，需先创建，dbpath用于指定数据存放位置 开启一个客户端访问数据库同样的bin文件夹下执行 &gt; mongo 默认连接至test数据库 显示帮助&gt; help 显示所有数据库名称&gt; show dbs 切换数据库&gt; use test 显示当前连接的数据库名称&gt; db 显示当前数据库所有集合&gt; show collections 显示数据库支持的方法&gt; db.help() 显示集合支持的方法&gt; db.users.help() 创建集合&gt; db.createCollection(&quot;users&quot;) 插入操作insert&gt; db.users.insert({&quot;name&quot;:&quot;kiinlam&quot;,&quot;age&quot;:28}) 查询操作find查找所有文档&gt; db.users.find() 查找指定文档&gt; db.users.find({&quot;name&quot;:&quot;kiinlam&quot;}) 查询一条&gt; db.users.findOne({&quot;name&quot;:&quot;kiinlam&quot;}) 大于$gt&gt; db.users.find({&quot;age&quot;:{$gt:22}}) 大于等于$gte&gt; db.users.find({&quot;age&quot;:{$gte:22}}) 小于$lt&gt; db.users.find({&quot;age&quot;:{$lt:22}}) 小于等于$gte&gt; db.users.find({&quot;age&quot;:{$lte:22}}) 不等于$ne&gt; db.users.find(&quot;age&quot;:{$ne:22}) 或$or&gt; db.users.find({$or:[{&quot;name&quot;:&quot;kiinlam&quot;},{&quot;name&quot;:&quot;cheungkiinlam&quot;}]}) 在集合中$in&gt; db.users.find(&quot;name&quot;:{$in:[&quot;kiinlam&quot;,&quot;cheungkiinlam&quot;]}) 不在集合中$nin&gt; db.users.find(&quot;name&quot;:{$nin:[&quot;kiinlam&quot;,&quot;cheungkiinlam&quot;]}) 正则查询&gt; db.users.find({&quot;name&quot;:/^k/,&quot;name&quot;:/m$/}) 筛选查询$where// 使用js function作为筛选条件 &gt; db.users.find({$where: function(){return this.name==&apos;kiinlam&apos;}}) 限制查询数量limit&gt; db.users.find({&quot;age&quot;:22}).limit(10) 更新操作update指定文档全部更新，等于覆盖&gt; db.users.update({&quot;name&quot;:&quot;kiinlam&quot;}, {&quot;name&quot;:&quot;cheungkiinlam&quot;,&quot;age&quot;:27}) 局部更新一：增量更新$inc// age增加2，其他不变 &gt; db.users.update({&quot;name&quot;:&quot;kiinlam&quot;}, {$inc:{&quot;age&quot;:2}}) 局部更新二：字段修改$set// age改为20 &gt; db.users.update({&quot;name&quot;:&quot;kiinlam&quot;}, {$set:{&quot;age&quot;:20}}) 新增更新：如果不存在，就新增一条// 第三个参数为true &gt; db.users.update({&quot;name&quot;:&quot;kiinlam&quot;}, {$set:{&quot;age&quot;:18}}, true) 批量更新// 如果匹配多条，默认只改第一条，将第四个参数设为true可全部更新 &gt; db.users.update({&quot;name&quot;:&quot;kiinlam&quot;}, {$set:{&quot;age&quot;:18}}, true, true) 保存操作save// 插入新文档，如果不提供&quot;_id&quot;字段 &gt; db.users.save({&quot;name&quot;:&quot;kiinlam&quot;, &quot;age&quot;:28}) // 更新已存在的文档 &gt; db.users.save({&quot;_id&quot;:&quot;xxx&quot;,&quot;name&quot;:&quot;kiinlam&quot;, &quot;age&quot;:28}) 删除操作remove删除操作不可恢复 删除所有，但不删除索引&gt; db.users.remove({}) 删除指定文档&gt; db.users.remove({&quot;name&quot;:&quot;kiinlam&quot;}) 删除一条指定文档，如果有多条结果&gt; db.users.remove({&quot;name&quot;:&quot;kiinlam&quot;}, true) 完全删除集合，包括索引，应当使用drop 大量删除时，采用复制需要保留的文档到新集合，再用drop删除集合。 删除数据库&gt; db.dropDatabase() 删除集合&gt; db.users.drop() 计数操作count&gt; db.users.count() &gt; db.users.count({&quot;age&quot;:29}) 唯一值查询distinct指定字段有多个相同时，只取一个，返回指定字段的值组合成的数组&gt; db.users.distinct(&quot;age&quot;) 分组操作group按照age进行分组操作，分组结果存放在user中，值为对应age的name值的数组 key：分组依据 initial：初始化函数，每个不同的age组共享同一个函数 $reduce： 第一个参数为当前文档，第二参数为前一次函数操作的累计对象，第一次为initial对应的对象 &gt; db.users.group({ &quot;key&quot;: {&quot;age&quot;: true}, &quot;initial&quot;: {&quot;user&quot;: []}, &quot;$reduce&quot;: function(cur,prev){ prev.user.push(cur.name); } }) 假设有数据如下： { &quot;_id&quot; : ObjectId(&quot;55910457607379845607d9e2&quot;), &quot;name&quot; : &quot;kiinlam&quot;, &quot;age&quot; : 29 } { &quot;_id&quot; : ObjectId(&quot;55910468607379845607d9e3&quot;), &quot;name&quot; : &quot;shadow&quot;, &quot;age&quot; : 26 } { &quot;_id&quot; : ObjectId(&quot;55910992607379845607d9e5&quot;), &quot;name&quot; : &quot;foo&quot;, &quot;age&quot; : 29 } { &quot;_id&quot; : ObjectId(&quot;55911fca607379845607d9e6&quot;), &quot;name&quot; : &quot;dd&quot;, &quot;age&quot; : 22 } { &quot;_id&quot; : ObjectId(&quot;55911fd3607379845607d9e7&quot;), &quot;name&quot; : &quot;mm&quot;, &quot;age&quot; : 22 } { &quot;_id&quot; : ObjectId(&quot;55911fdf607379845607d9e8&quot;), &quot;name&quot; : &quot;gg&quot;, &quot;age&quot; : 22 } { &quot;_id&quot; : ObjectId(&quot;55911feb607379845607d9e9&quot;), &quot;name&quot; : &quot;jj&quot;, &quot;age&quot; : 22 } { &quot;_id&quot; : ObjectId(&quot;55920545ff40738c1fd0a839&quot;), &quot;name&quot; : &quot;zz&quot;, &quot;age&quot; : 1 } 分组结果为： [ { &quot;age&quot; : 29, &quot;user&quot; : [ &quot;kiinlam&quot;, &quot;foo&quot; ] }, { &quot;age&quot; : 26, &quot;user&quot; : [ &quot;shadow&quot; ] }, { &quot;age&quot; : 22, &quot;user&quot; : [ &quot;dd&quot;, &quot;mm&quot;, &quot;gg&quot;, &quot;jj&quot; ] }, { &quot;age&quot; : 1, &quot;user&quot; : [ &quot;zz&quot; ] } ] 更多分组功能可选参数: condition 和 finalize。 `condition` —— 过滤条件 `finalize` —— 函数，分组完成后执行 过滤掉age大于22的文档，增加属性标明分组中文档的数量 &gt; db.users.group({ &quot;key&quot;: {&quot;age&quot;: true}, &quot;initial&quot;: {&quot;user&quot;: []}, &quot;$reduce&quot;: function(cur,prev){ prev.user.push(cur.name); }, &quot;condition&quot;: {&quot;age&quot;:{$lte:22}}, &quot;finalize&quot;: function(out){ out.count = out.user.length; } }) 分组结果为： [ { &quot;age&quot; : 22, &quot;user&quot; : [ &quot;dd&quot;, &quot;mm&quot;, &quot;gg&quot;, &quot;jj&quot; ], &quot;count&quot; : 4 }, { &quot;age&quot; : 1, &quot;user&quot; : [ &quot;zz&quot; ], &quot;count&quot; : 1 } ] mapReducemap：映射函数，内部调用emit(key,value)，集合按照key进行映射分组。 reduce：简化函数，对map分组后的数据进行分组简化，reduce(key,value)中的key是emit中的key，而value则是emit分组结果的集合。 mapReduce：最后执行的函数，参数为map、reduce和一些可选参数。 &gt; db.users.mapReduce function ( map , reduce , optionsOrOutString ){ var c = { mapreduce : this._shortName , map : map , reduce : reduce }; assert( optionsOrOutString , &quot;need to supply an optionsOrOutString&quot; ) if ( typeof( optionsOrOutString ) == &quot;string&quot; ) c[&quot;out&quot;] = optionsOrOutString; else Object.extend( c , optionsOrOutString ); var raw = this._db.runCommand( c ); if ( ! raw.ok ){ __mrerror__ = raw; throw Error( &quot;map reduce failed:&quot; + tojson(raw) ); } return new MapReduceResult( this._db , raw ); } 创建map函数 function (){ emit(this.name,{count:1}); } 创建reduce函数 function (key,value){ var result = {count:0}; for(var i = 0; i &lt; value.length; i++){ result.count += value[i].count; } return result; } 执行mapReduce操作 &gt; db.users.mapReduce(map,reduce,{&quot;out&quot;:&quot;collection&quot;}) 假设有数据如下 { &quot;_id&quot; : ObjectId(&quot;55910457607379845607d9e2&quot;), &quot;name&quot; : &quot;kiinlam&quot;, &quot;age&quot; : 29 } { &quot;_id&quot; : ObjectId(&quot;55910468607379845607d9e3&quot;), &quot;name&quot; : &quot;shadow&quot;, &quot;age&quot; : 26 } { &quot;_id&quot; : ObjectId(&quot;55910992607379845607d9e5&quot;), &quot;name&quot; : &quot;foo&quot;, &quot;age&quot; : 29 } { &quot;_id&quot; : ObjectId(&quot;55920545ff40738c1fd0a839&quot;), &quot;name&quot; : &quot;zz&quot;, &quot;age&quot; : 1 } { &quot;_id&quot; : ObjectId(&quot;55911fca607379845607d9e6&quot;), &quot;name&quot; : &quot;foo&quot;, &quot;age&quot; : 22 } { &quot;_id&quot; : ObjectId(&quot;55911fd3607379845607d9e7&quot;), &quot;name&quot; : &quot;foo&quot;, &quot;age&quot; : 22 } { &quot;_id&quot; : ObjectId(&quot;55911fdf607379845607d9e8&quot;), &quot;name&quot; : &quot;foo&quot;, &quot;age&quot; : 22 } { &quot;_id&quot; : ObjectId(&quot;55911feb607379845607d9e9&quot;), &quot;name&quot; : &quot;foo&quot;, &quot;age&quot; : 22 } 输出结果 { &quot;result&quot; : &quot;collection&quot;, // 存放最终结果的集合名 &quot;timeMillis&quot; : 28, &quot;counts&quot; : { &quot;input&quot; : 8, // 传入文档的次数 &quot;emit&quot; : 8, // emit函数被调用次数 &quot;reduce&quot; : 1, // reduce函数被调用次数 &quot;output&quot; : 4 // 最后返回文档的个数 }, &quot;ok&quot; : 1 } 查看集合collection中的结果 &gt; db.collection.find() 输出结果 { &quot;_id&quot; : &quot;foo&quot;, &quot;value&quot; : { &quot;count&quot; : 5 } } { &quot;_id&quot; : &quot;kiinlam&quot;, &quot;value&quot; : { &quot;count&quot; : 1 } } { &quot;_id&quot; : &quot;shadow&quot;, &quot;value&quot; : { &quot;count&quot; : 1 } } { &quot;_id&quot; : &quot;zz&quot;, &quot;value&quot; : { &quot;count&quot; : 1 } } 游标游标只表示一个引用，并不是真正的执行，在需要的时候，通过for循环或next()方法进行遍历读取，枚举结束后，游标销毁，不再返回数据。 申明一个游标 &gt; var list = db.collection.find() 通过forEach遍历游标 &gt; list.forEach(function(i){ print(i._id); }) 输出结果 foo kiinlam shadow zz 或者通过next遍历集合 &gt; var list = db.collection.find() &gt; list.next() { &quot;_id&quot; : &quot;foo&quot;, &quot;value&quot; : { &quot;count&quot; : 5 } } &gt; list.next() { &quot;_id&quot; : &quot;kiinlam&quot;, &quot;value&quot; : { &quot;count&quot; : 1 } } &gt; list.next() { &quot;_id&quot; : &quot;shadow&quot;, &quot;value&quot; : { &quot;count&quot; : 1 } } &gt; list.next() { &quot;_id&quot; : &quot;zz&quot;, &quot;value&quot; : { &quot;count&quot; : 1 } } &gt; list.next() 2015-07-01T11:27:38.186+0800 E QUERY Error: error hasNext: false at Error (&lt;anonymous&gt;) at DBQuery.next (src/mongo/shell/query.js:255:15) at (shell):1:6 at src/mongo/shell/query.js:255 &gt; list &gt; 索引ensureIndex建立索引// 1为升序，-1为降序 &gt; db.users.ensureIndex({&quot;name&quot;:1}) 唯一索引&gt; db.users.ensureIndex({&quot;name&quot;:1},{&quot;unique&quot;:true}) 组合索引&gt; db.users.ensureIndex({&quot;name&quot;:1, &quot;age&quot;:-1}) 查看索引&gt; db.users.getIndexes() 按指定索引查询&gt; db.users.find({&quot;name&quot;:&quot;kiinlam&quot;}).hint({&quot;name&quot;:1,&quot;age&quot;:1}) 删除索引// 删除所有自定义索引 &gt; db.users.dropIndexes() // 删除指定索引 &gt; db.users.dropIndex(&quot;name_1&quot;) 性能分析函数explain&gt; db.users.find().explain(&quot;executionStats&quot;) 主从数据库部署创建主数据库master&gt; mongod --dbpath=XXX --master 创建从数据库slave// 指定从数据库端口--port // 指定主数据库源--source &gt; mongod --dbpath=XXX --port=8888 --slave --source=127.0.0.1:27017 后期指定主数据库源&gt; mongod --dbpath=XXX --port=8888 --slave // 后期添加源 // 切换到local数据库 &gt; use local // 在sources中加入源地址 &gt; db.sources.insert({&quot;host&quot;:&quot;127.0.0.1:27017&quot;}) 副本集replSet该架构没有特定的主数据库，一个数据库宕机了，另一个数据库会顶上 创建第一个数据库服务器// 需要指定集群名及下一个数据库地址 &gt; mongod --dbpath=XXX --port 2222 --replSet mySet/127.0.0.1:3333 创建第二个数据库服务器&gt; mongod --dbpath=XXX --port 3333 --replSet mySet/127.0.0.1:2222 初始化副本集// 进入任一数据库的admin集合 &gt; mongo 127.0.0.1:2222/admin // 执行初始化操作 &gt; db.runCommand({ &quot;replSetInitiate&quot;:{ &quot;_id&quot;:&quot;mySet&quot;, &quot;members&quot;:[ { &quot;_id&quot;:1, &quot;host&quot;:&quot;127.0.0.1:2222&quot; }, { &quot;_id&quot;:2, &quot;host&quot;:&quot;127.0.0.1:3333&quot; } ] } }) 仲裁服务器// 启动仲裁服务器 &gt; mongod --dbpath=XXX --port 4444 --replSet mySet/127.0.0.1:2222 // 回到admin集合中添加仲裁服务器 &gt; mongo 127.0.0.1:2222/admin &gt; rs.addArb(&quot;127.0.0.1:4444&quot;) // 查看服务器集群状态 &gt; rs.status() 分片技术将集合进行拆分，将拆分的数据均摊到几个分片上。 主要参与者： 客户端 路由服务器mongos 配置服务器 分片数据库实例 开启配置服务器config&gt; mongod --dbpath=XXX --port 2222 开启路由服务器mongos// 指定配置服务器 &gt; mongos --port 3333 --configdb=127.0.0.1:2222 开启分片数据库服务器mongod&gt; mongod --dbpath=XXX --port 4444 &gt; mongod --dbpath=XXX --port 5555 服务配置// 进入mongos数据库admin集合 &gt; mongo 127.0.0.1:3333/admin // 添加分片服务器addshard &gt; db.runCommand({ &quot;addshard&quot;:&quot;127.0.0.1:4444&quot;, &quot;allowLocal&quot;:true }) &gt; db.runCommand({ &quot;addshard&quot;:&quot;127.0.0.1:5555&quot;, &quot;allowLocal&quot;:true }) // 开启数据库test的分片功能enablesharding &gt; db.runCommand({&quot;enablesharding&quot;:&quot;test&quot;}) // 指定集合中分片的片键users.name &gt; db.runCommand({&quot;shardcollection&quot;:&quot;test.users&quot;,&quot;key&quot;:{&quot;name&quot;:1}}) // 在mongos中查看数据分片情况 &gt; use test &gt; db.printShardingStatus() 运维运维通常会涉及到以下4个方面 安装部署 状态监控 安全认证 备份和恢复 安装部署为windows服务// 指定日志路径，添加install参数 &gt; mongod --dbpath=XXX --logpath=XXX --port=2222 --install // 启动服务 &gt; net start MongoDB 状态监控静态统计db.stats() // 查看单个数据库状态 &gt; db.stats() stats比较简单，可以参考db.stats()一文 db.serverStatus() // 查看整个mongodb的状态 // 进入admin集合 &gt; mongo 127.0.0.1:2222/admin // 查看状态 &gt; db.serverStatus() serverStatus的参数很多，可以参考db.serverStatus()一文 实时统计&gt; mongostat --port 2222 安全认证TODO 有点复杂，偷懒了，参考安全认证 备份和恢复// 备份test数据库到D:\mongodb\backup &gt; mongodump --port 2222 -d test -o D:\mongodb\backup // 恢复数据，drop表示恢复前删除原有数据 &gt; mongorestore --port 2222 -d test --drop D:\mongodb\backup 参考资料 mongoDB MongoDB文档 install-mongodb-on-windows 8天学通MongoDB系列]]></content>
      <categories>
        <category>mongoDB</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS终端使用subl运行Sublime Text 3]]></title>
    <url>%2F2015%2F05%2F09%2FMac-OS%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8subl%E8%BF%90%E8%A1%8CSublime-Text-3%2F</url>
    <content type="text"><![CDATA[1.添加link1ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl 2.编辑PATH1vim ~/.bash_profile 3.添加PATH1export PATH=/usr/local/bin:$PATH 1esc -&gt; shift + : -&gt; wq保存退出 4.应用1source ~/.bash_profile]]></content>
      <tags>
        <tag>macOS</tag>
        <tag>Sublime</tag>
        <tag>Editor</tag>
      </tags>
  </entry>
</search>
