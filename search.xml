<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[新版知乎模拟登陆]]></title>
    <url>%2F2018%2F02%2F10%2F%E6%96%B0%E7%89%88%E7%9F%A5%E4%B9%8E%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[概述在群里经常看到有人问知乎的登录方式,记得以前写过模拟登陆的案例,但是由于改版的原因已经失效了 从新看了一下知乎登录的流程 对于新手来说确实有一定的难度，主要是分析js的加密方法,对于js渣渣来说简直就是噩梦。 流程分析输入一个错误的密码 查看请求因为知乎登录教程比较多 这里着重看登录请求 captcha没啥好说的从request headers中我们可以找到请求头 当然还有很重要的一个参数authorization:oauth c3cef7c66a1843f8b3a9e6a1e3160e20我们打开一个隐身窗口 输入不同的账户再次模拟 发现这个参数的是不变的 那就不用去探究他的由来 直接用最重要的是payload部分增加了新的 参数 可能看起来怪怪的 跟以前看到的payload 不一样 但是还是很用容易发现规律 去掉 “——WebKitFormBoundarygbNkZ3Q6sZBpmPVk” 提取nameclient_id=c3cef7c66a1843f8b3a9e6a1e3160e20得到了这种格式因此我们就知道我们需要提交哪一些参数了12345678910111213&#123; client_id grant_type timestamp source signature username password captcha lang ref_source utm_source&#125; 比较两次模拟 发现除了signature是变化了 cliient_id就是authorization中的一部分 timestamp有经验的人一看就知道是时间戳 大部分的人也是到这里就不知道怎么办了 signature在html中找不到 那么肯定在js中 我们去js中搜索关键字”signature” 最后定位到了https://static.zhihu.com/heifetz/main.app.7bfdc6cca34029fdef12.![](http://ozelrebbz.bkt.clouddn.com/9d70f2b6c14c91b386f3a24031005fd4.png)因为文件比较大 我们拷贝到编辑器中 这里推荐一波sublime text 同时使用js format插件格式化(百度),当然也可以在线格式化这个是signature相关函数 到这里我们基本可以猜测出他的加密方式了hmacHMAC 是用于消息认证的加密哈希算法，全称是 keyed-Hash Message Authentication Code。HMAC 利用哈希算法，以一个密钥和一个消息作为输入，生成一个加密串作为输出。HMAC 可以有效防止类似 MD5 的彩虹表等攻击，比如将常见密码的 MD5 值存入数据库，可能被反向破解。Python 的 hmac 模块提供了 HMAC 算法，它的使用形式是：1hmac.new(key[, msg[, digestmod]]) 其中，key 是一个密钥；msg 是消息，可选，如果给出 msg，则调用方法 update(msg)；digestmod 是 HMAC 对象使用的摘要构造函数或模块，默认为 hashlib.md5 构造函数。m.update(a);m.update(b);相当于：m.update(a+b) HMAC.digest()返回目前传递给 update() 方法的字符串的摘要。此字符串长度将与给构造函数的摘要的 digest_size 相同。它可能包含非 ASCII 字符，包括 NULL 字节。 HMAC.hexdigest()类似 digest()，但是返回的摘要的字符串的长度翻倍，且只包含十六进制数字1234567891011&gt;&gt;&gt; from datetime import datetime&gt;&gt;&gt; import hashlib&gt;&gt;&gt; import hmac&gt;&gt;&gt; key = 'you-never-know'&gt;&gt;&gt; msg = datetime.utcnow().strftime('%Y-%m-%d')&gt;&gt;&gt; m = hmac.new(key, msg, hashlib.sha1)&gt;&gt;&gt; signature = m.hexdigest()&gt;&gt;&gt; signature'fdb2087a66a2f00afbc1884738467ba089782779' 那么加密参数有哪些呢？ ‘d1b964811afb40118a12068ff74a12f4’ e i.a ‘com.zhihu.web’ n这里的e，i.a,n是啥 不知道 那么在来看下这个1234567&#123; clientId: i.a, grantType: e, timestamp: n, source: "com.zhihu.web", signature: r.getHMAC("HEX") &#125; 是不是很熟悉 没错 都是我们需要获取的参数 所以i.a就是cliendId，e就是字符串password,= Date.now() 这样加密的参数就齐了我们来测试一下跟js加密得到的signature是一样的。完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import requestsimport timeimport hmacimport osfrom hashlib import sha1import jsonfrom bs4 import BeautifulSoupsession=requests.session()def get_signature(st): key = 'd1b964811afb40118a12068ff74a12f4' signature = hmac.new(key.encode('utf-8'), ''.encode('utf-8'), sha1) signature.update("password".encode('utf-8')) signature.update("c3cef7c66a1843f8b3a9e6a1e3160e20".encode('utf-8')) signature.update("com.zhihu.web".encode('utf-8')) signature.update(st.encode('utf-8')) signature.hexdigest() return signature.hexdigest()def is_login(account): '''自动检测本地是否有cookies文件 如果有文件 检测是否登录''' cf="cookies_"+str(account) if os.path.exists(cf): cookie_dict=json.loads(open(cf,'r').read()) session.cookies = requests.utils.cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True) r=session.get("https://www.zhihu.com/settings/profile",allow_redirects=False) if r.status_code==200: print("登录成功") soup=BeautifulSoup(r.text,'html.parser') try: nickname=soup.find_all(class_="name")[0].text except: nickname = "没有获取到昵称!" print("hello "+nickname) return True else: print(r.status_code) return False else: print("cookies不存在") return Falsedef zhihu_login(account,password): header = &#123; 'host': 'www.zhihu.com', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.89 Safari/537.36', 'Referer': 'https://www.zhihu.com/', 'authorization': 'oauth c3cef7c66a1843f8b3a9e6a1e3160e20' &#125; session.headers=header if is_login(account): return True captcha_url = 'https://www.zhihu.com/api/v3/oauth/captcha?lang=en' response = session.get(captcha_url) show_captcha = json.loads(response.text)['show_captcha'] if not show_captcha: captcha = '' else: img_resp=session.get(captcha_url) with open('captcha.jpg', 'wb') as f: f.write(img_resp.content) captcha = input("please input the captcha\n&gt;") st = str(int(time.time() * 1000)) form_data = &#123; 'client_id': 'c3cef7c66a1843f8b3a9e6a1e3160e20', 'grant_type': 'password', 'timestamp': st, 'source': 'com.zhihu.web', 'signature': get_signature(st), 'username': account, 'password': password, 'captcha': captcha, 'lang': 'cn', 'ref_source': 'homepage', 'utm_source': '', &#125; login_url = 'https://www.zhihu.com/api/v3/oauth/sign_in' result = session.post(login_url, data=form_data) login_json=json.loads(result.text) if "access_token" in login_json.keys(): print("登錄成功") #保存cookie cookies = requests.utils.dict_from_cookiejar(session.cookies) with open("cookies_"+str(account),'w') as f: f.write(json.dumps(cookies)) else: print(login_json)zhihu_login("你的用户","密码")]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫，知乎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyPt5 浏览器实例]]></title>
    <url>%2F2018%2F02%2F02%2FPyPt5-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[导入包pyQt5.6 以后QtWebEngineWidgets 替代了QtWebWidgets12345from PyQt5.QtCore import *from PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtWebEngineWidgets import QWebEngineViewimport sys 主窗口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class MainWindow(QMainWindow): # noinspection PyUnresolvedReferences def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.setWindowTitle('Bingo Browser') self.setWindowIcon(QIcon('images/title.png')) # self.resize(900, 600) self.showMaximized() self.show() #浏览器 self.browser = QWebEngineView() url = 'http://tongchengbin.github.io' # 指定打开界面的 URL self.browser.setUrl(QUrl(url)) # 添加浏览器到窗口中 self.setCentralWidget(self.browser) ###使用QToolBar创建导航栏，并使用QAction创建按钮 # 添加导航栏 navigation_bar = QToolBar('Navigation') # 设定图标的大小 navigation_bar.setIconSize(QSize(16, 16)) #添加导航栏到窗口中 self.addToolBar(navigation_bar) #QAction类提供了抽象的用户界面action，这些action可以被放置在窗口部件中 # 添加前进、后退、停止加载和刷新的按钮 back_button = QAction(QIcon('images/back.png'), 'Back', self) next_button = QAction(QIcon('images/go.png'), 'Forward', self) stop_button = QAction(QIcon('images/stop.png'), 'stop', self) reload_button = QAction(QIcon('icons/refresh.png'), 'reload', self) back_button.triggered.connect(self.browser.back) next_button.triggered.connect(self.browser.forward) stop_button.triggered.connect(self.browser.stop) reload_button.triggered.connect(self.browser.reload) # 将按钮添加到导航栏上 navigation_bar.addAction(back_button) navigation_bar.addAction(next_button) navigation_bar.addAction(stop_button) navigation_bar.addAction(reload_button) #添加URL地址栏 self.urlbar = QLineEdit() # 让地址栏能响应回车按键信号 self.urlbar.returnPressed.connect(self.navigate_to_url) navigation_bar.addSeparator() navigation_bar.addWidget(self.urlbar) #让浏览器相应url地址的变化 self.browser.urlChanged.connect(self.renew_urlbar) def navigate_to_url(self): q = QUrl(self.urlbar.text()) if q.scheme() == '': q.setScheme('http') self.browser.setUrl(q) def renew_urlbar(self, q): # 将当前网页的链接更新到地址栏 self.urlbar.setText(q.toString()) self.urlbar.setCursorPosition(0) 运行实例12345if __name__ == "__main__": app = QApplication(sys.argv) window = MainWindow() window.show() app.exec_() 效果图]]></content>
      <tags>
        <tag>Python PyQt5 便携浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQT5整体结构]]></title>
    <url>%2F2018%2F01%2F29%2FPyQT5%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[1 PyQt5整体介绍PyQt5是基于图形程序框架Qt5的Python语言实现，由一组Python模块构成。如图A-1所示。PyQt5包括的主要模块如下。 QtCore模块——涵盖了包的核心的非GUI功能，此模块被用于处理程序中涉及的时间、文件、目录、数据类型、文本流、链接、QMimeData、线程或进程等对象。 QtGui模块——涵盖了多种基本图形功能的类，包括但不限于：窗口集、事件处理、2D图形、基本的图像和界面、字体和文本类。 QtWidgets模块——包含了一整套UI元素控件，用于建立符合系统风格的Classic界面，非常方便，可以在安装时选择是否使用此功能。 QtMultimedia模块——包含了一套类库，用于处理多媒体事件，通过调用API接口访问摄像头、语音设备、收发消息（Radio Functionality）等。 QtBluetooth模块——包含了处理蓝牙活动的类库，其功能包括：扫描设备、连接、交互等行为。 QtNetwork模块——包含了用于进行网络编程的类库，通过提供便捷的TCP/IP及UDP的C/S代码集合，使得基于Qt的网络编程更容易。 QtPositioning模块——用于获取位置信息，此模块允许使用多种方式实现定位，包括但不限于：卫星、无线网、文字信息。此模块一般用在网络地图定位系统中。 Enginio模块——用于构建客户端的应用程序库，在运行时访问Qt Cloud 服务器托管的应用程序。QtWebSockets模块——包含了一组类程序，用于实现WebSocket协议。QtWebKit模块——包含了用于实现基于WebKit2的网络浏览器的类库。 QtWebKitWidgets模块——提供了一组类库，用于实现一种由Widgets包构建的、基于WebKit1的网络浏览器。 QtXml模块——包含了用于处理XML的类库，此模块为SAX和DOM API 的实现提供了函数。 QtSvg模块——通过一组类库，为显示矢量图形文件的内容提供了函数。 QtSql模块——提供了数据库对象的接口以供使用。 QtTest模块——包含了通过单元测试，调试PyQt5应用程序的功能。 QtHelp模块——包含了用于创建和查看可查找的文档的类。 QtOpenGL模块——使用OpenGL库来渲染3D和2D图形。该模块使得Qt GUI库和OpenGL库无缝集成。 QtXmlPatterns模块——所包含的类实现了对XML和自定义数据模型的Xquery与XPath的支持。 QtDesigner模块——所包含的类允许使用PyQt扩展Qt Designer。 Qt模块——将上面模块中的类综合到一个单一的模块中。这样做的好处是你不用担心哪个模块包含了哪个特定的类；坏处是加载到整个Qt框架中，从而增加了应用程序的内存占用。 uic模块——所包含的类用来处理.ui文件，该文件由Qt Designer创建，用于描述整个或者部分用户界面。它可以将.ui文件编译为.py文件，以便其他Python程序调用。PyQt5增加了很多模块，可以去官方网站查看，基本上看模块名字就知道大概用处了。PyQt5已经没有phonon模块了，使用QtMultimedia来处理媒体。另外，PyQt5新增的QtWebEngineWidgets模块替代了过时的QtWebKit，但是QtWebKit还在，而新模块更耗内存，具体使用哪个由读者自己决定。.2 PyQt 5主要类介绍PyQt5 API拥有620多个类和6000个函数。它是一个跨平台的工具包，可以运行在所有主流的操作系统上，包括Windows、Linux和Mac OS。 QObject类：在类层次结构中是顶部类（Top Class），它是所有PyQt对象的基类。 QPaintDevice类：所有可绘制的对象的基类。 QApplication类：用于管理图形用户界面应用程序的控制流和主要设置。它包含主事件循环，对来自窗口系统和其他资源的所有事件进行处理和调度；它也对应用程序的初始化和结束进行处理，并且提供对话管理；还对绝大多数系统范围和应用程序范围的设置进行处理。 QWidget类：所有用户界面对象的基类。QDialog类和QFrame类继承自QWidget类，这两个类有自己的子类系统（Sub-Class System）。 QFrame类：有框架的窗口控件的基类。它也被用来直接创建没有任何内容的简单框架，但是通常要用到QHBox或QVBox，因为它们可以自动布置放到框架中的窗口控件。 QMainWindow类：提供一个有菜单栏、锚接窗口（如工具栏）和状态栏的主应用程序窗口。 QDialog类：最普通的顶级窗口。如果一个窗口控件没有被嵌入到父窗口控件中，那么该窗口控件就被称为顶级窗口控件。在通常情况下，顶级窗口控件是有框架和标题栏的窗口。在Qt中，QMainWindow和不同的QDialog的子类是最普通的顶级窗口。图A-2至图A-6展示了PyQt 5中重要的类及其继承关系。上面的类图是使用UML建模工具Edraw UML Diagram绘制的。比如在图A-2所示的类图中，每一个方框代表一个PyQt 5的类，在方框的第一行显示的是类名，方框之间通过符号表示类与类之间的继承关系。继承指的是一个类（称为子类）继承另一个类（称为父类）的功能，通过继承可以增加子类的新功能。下面是常用的控件。 QLabel控件：用来显示文本或图像。 QLineEdit窗口控件：提供了一个单页面的单行文本编辑器。 QTextEdit窗口控件：提供了一个单页面的多行文本编辑器。 QPushButton窗口控件：提供了一个命令按钮。 QRadioButton控件：提供了一个单选钮和一个文本或像素映射标签。 QCheckBox窗口控件：提供了一个带文本标签的复选框。 QspinBox控件：允许用户选择一个值，要么通过按向上/向下键增加/减少当前显示值，要么直接将值输入到输入框中。 QScrollBar窗口控件：提供了一个水平的或垂直的滚动条。 QSlider控件：提供了一个垂直的或水平的滑动条。 QComboBox控件：一个组合按钮，用于弹出列表。 QMenuBar控件：提供了一个横向菜单栏。 QStatusBar控件：提供了一个适合呈现状态信息的水平条，通常放在QMainWindow的底部。 QToolBar控件：提供了一个工具栏，可以包含多个命令按钮，通常放在QMainWindow的顶部。 QListView控件：可以显示和控制可选的多选列表，可以设置ListMode或IconMode。 QPixmap控件：可以在绘图设备上显示图像，通常放在QLabel或QPushButton类中。 Qdialog控件：对话框窗口的基类。QWidget是所有用户界面类的基类，它能接收所有的鼠标、键盘和其他系统窗口事件。没有被嵌入到父窗口中的Widget会被当作一个窗口来调用，当然，它也可以使用setWindowFlags(Qt.WindowFlags)函数来设置窗口的显示效果。QWidget的构造函数可以接收两个参数，其中第一个参数是该窗口的父窗口；第二个参数是该窗口的Flag，也就是Qt.WindowFlags。根据父窗口来决定Widget是嵌入到父窗口中还是被当作一个独立的窗口来调用，根据Flag来设置Widget窗口的一些属性。QMainWindow（主窗口）一般是应用程序的框架，在主窗口中可以添加所需要的Widget，比如添加菜单栏、工具栏、状态栏等。主窗口通常用于提供一个大的中央窗口控件（如文本编辑或者绘制画布）以及周围的菜单栏、工具栏和状态栏。QMainWindow常常被继承，这使得封装中央控件、菜单栏，工具栏以及窗口状态变得更容易，也可以使用Qt Designer来创建主窗口。 3 QApplication类QApplication类用于管理图形用户界面应用程序的控制流和主要设置，可以说QApplication是PyQt的整个后台管理的命脉。任何一个使用PyQt开发的图形用户界面应用程序，都存在一个QApplication对象。在PyQt中，可以通过如下代码载入必需的模块，获得QApplication类。1from PyQt5.QtWidgets import QApplication 在PyQt的应用程序实例中包含了QApplication类的初始化，通常放在Python脚本的if name == “main“: 语句后面，类似于放在C的main函数里，作为主程序的入口。因为QApplication对象做了很多初始化，所以它必须在创建窗口之前被创建。QApplication类还可以处理命令行参数，在QApplication类初始化时，需要引入参数sys.argv。sys.argv是来自命令行的参数列表，Python脚本可以从shell运行，比如用鼠标双击qtSample.py，就启动了一个PyQt应用程序。引入sys.argv后就能让程序从命令行启动，比如在命令行中输入 python qtSample.py，也可以达到同样的效果。QApplication类的初始化可以参考以下脚本引用。应用程序整体框架为：12345if __name__ == "__main__": app = QApplication(sys.argv) # 界面生成代码 ... sys.exit(app.exec_()) sys.exit()函数可以结束一个应用程序，使应用程序在主循环中退出。QApplication采用事件循环机制，当QApplication初始化后，就进入应用程序的主循环（Main Loop），开始进行事件处理，主循环从窗口系统接收事件，并将这些事件分配到应用程序的控件中。当调用sys.exit()函数时，主循环就会结束。PyQt 5的应用程序是事件驱动的，比如键盘事件、鼠标事件等。在没有任何事件的情况下，应用程序处于睡眠状态。主循环控制应用程序什么时候进入睡眠状态，什么时候被唤醒。]]></content>
      <categories>
        <category>PyQt</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 下配置django+uwsgi]]></title>
    <url>%2F2018%2F01%2F09%2Fdjango%20%2B%20nginx%20%2B%20uwsgi%2F</url>
    <content type="text"><![CDATA[WSGI配置123456import os, sys# 这里是服务器中的项目目录sys.path.append('/home/www/rana')from django.core.wsgi import get_wsgi_applicationos.environ.setdefault("DJANGO_SETTINGS_MODULE", "rana.settings")application = get_wsgi_application() 接下来使用uwsgi运行一下项目1uwsgi --plugin http,python --http :8000 --wsgi-file wsgi.py 使用http协议运行wsgi.py，这时用浏览器访问会看到没有静态文件(js,css等)的页面，然后就是第二步，使用nginx做静态文件服务器。 nginx做静态文件服务器想让nginx跑起来就要麻烦一点了。 1.修改nginx.confnginx.conf文件在 /etc/nginx 目录下，把user的值改为当前用户，否则会有权限问题。 2.如果需要用到80端口如果需要用到80端口的话，就把 /etc/nginx/conf.d 目录下的default.conf删掉吧，因为80端口会冲突的。 3.新建conf文件还是在 /etc/nginx/conf.d 目录下，新建一个conf文件，名字随便取，因为nginx.conf中有include conf.d/*.conf 这句，所有conf文件都会被读取。 新建的conf文件内容如下：12345678910111213141516171819202122server &#123; listen 80;#启动的nginx进程监听请求的端口 server_name localhost;#域名，如果用vps就把vps的ip填上#nginx错误日志，可自行设置，但必须保证提前建立好该目录和文件 error_log /home/www/log/error.log; location / &#123; include /etc/nginx/uwsgi_params; uwsgi_pass localhost:9090;#对于动态请求，转发到本机的9090端口， #也就是uwsgi监听的端口，这个只要不冲突就可以随意，#不过之后运行uwsgi时填写的socket要和它一样 &#125; #error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; location /static/ &#123; alias /home/www/rana/static/;#设定静态文件所在目录，要保证目录已经建好 &#125; location /media/ &#123; alias /home/www/rana/media/; #设定用户上传的媒体文件所在目录，要保证目录已经建好 &#125;&#125; 5.运行nginx查看端口占用 netstat -autp停止80端口程序 kill pid 6.运行uwsgisession1uwsgi --socket :9090 --wsgi-file wsgi.py --daemonize /home/www/log/deamon.log 这条命令和之前的有区别，将http改为了socket，让nginx去访问此端口。 同样也要先建好log文件。deamonize是让uwsgi在后台运行，并把日志记录在log文件中，否则一关掉控制台就不能访问了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>django,linux,nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python图片云]]></title>
    <url>%2F2018%2F01%2F09%2Fpython%E5%9B%BE%E7%89%87%E4%BA%91%2F</url>
    <content type="text"><![CDATA[Python 小工具 把图片拼接成任意大小新图片 代码比较简单 看注释就好1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-#图片拼接import PIL.Image as Imageimport os, sysfile_dir = "C:\\Users\Administrator\Desktop\zhihu\zhihu_user\images\\full"def g(): for root, dirs, files in os.walk(file_dir): for file in files: yield os.path.join(root,file)gfile=g()import osfrom PIL import Image'''把当前目录下的10*10张jpeg格式图片拼接成一张大图片'''python:# 图片压缩后的大小width_i = 100height_i = 100:# 每行每列显示图片数量line_max = 10row_max = 10:# 参数初始化all_path = []num = 0pic_max = line_max * row_maxdirName = os.getcwd()toImage = Image.new('RGBA', (width_i * line_max, height_i * row_max))for i in range(0, row_max): for j in range(0, line_max): pic_fole_head = Image.open(next(gfile)) width, height = pic_fole_head.size tmppic = pic_fole_head.resize((width_i, height_i)) loc = (int(i % line_max * width_i), int(j % line_max * height_i)) # print("第" + str(num) + "存放位置" + str(loc)) toImage.paste(tmppic, loc) num = num + 1print(toImage.size)toImage.save("C:\\Users\Administrator\Desktop\merged.png") git https://github.com/tongchengbin/pythontools/blob/master/imgCloud.py]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python PIL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉诺塔游戏]]></title>
    <url>%2F2018%2F01%2F09%2F%E6%B1%89%E8%AF%BA%E5%A1%94%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[汉诺塔游戏背景资料 汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。 汉诺塔是印度一个古老传说的益智玩具。汉诺塔的移动也可以看做是递归函数。 游戏说明 我们对柱子编号为a, b, c，将所有圆盘从a移到c可以描述为： 如果a只有一个圆盘，可以直接移动到c； 如果a有N个圆盘，可以看成a有1个圆盘（底盘） + (N-1)个圆盘，首先需要把 (N-1) 个圆盘移动到 b，然后，将 a的最后一个圆盘移动到c，再将b的(N-1)个圆盘移动到c。 请编写一个函数，给定输入 n, a, b, c，打印出移动的步骤： move(n, a, b, c) 例如，输入 move(2, ‘A’, ‘B’, ‘C’)，打印出： A –&gt; B A –&gt; C B –&gt; C 1234567891011121314n=0# 所有的盘子从 a 移到 cdef hanoi(x, a, b, c): global n if x &gt; 0: # step1：除了下面最大的，剩余的盘子 从 a 移到 b hanoi(x-1, a, c, b) # step2:最大的盘子从 a 移到 c print('%s-&gt;%s' % (a, c)) n = n +1 # step3: 把剩余的盘子 从 b 移到 c hanoi(x-1, b, a, c)hanoi(10, 'A', 'B', 'C')print(n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2018%2F01%2F09%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[二分查找又叫折半查找，二分查找应该属于减治技术的成功应用。所谓减治法，就是将原问题分解成若干个子问题后，利用了规模为n的原问题的解与较小规模（通常是n/2）的子问题的解之间的关系。 二分查找二分查找利用了记录按关键码有序的特点，其基本思想为：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键码相等，则查找成功；若给定值小于中间记录的关键码，则在中间记录的左半边继续查找；若给定值大于中间记录的关键码，则在中间记录右半边区继续查找。不断重复上述过程，直到查找成功，或所查找的区域无记录，查找失败。二分查找的时间复杂度是O(log(n))，最坏情况下的时间复杂度是O(n)。如果k&lt; mid查找左边 如果k&gt; mid查找右边例如：在有序列表list [1, 3, 8, 12, 23, 31, 37, 42, 48, 58]中查找值为8的记录的。123456789101112131415161718def binary_search(lis, find) : low = 0 high = len(lis)-1 while low &lt;= high : mid = (low + high) // 2 if lis[mid] == find : return mid #左半边 elif lis[mid] &gt; find : high = mid -1 #右半边 else : low = mid + 1 #未找到返回-1 return -1l=[1,2,3,4,5,6,7,8]x=binary_search(l,8)print(x) 递归的方案1234567891011121314def bin_search_rec(data_set, value, low=None, high=None): if not low or not high: low=0 high = len(data_set)-1 if low &lt;= high: mid = (low + high) // 2 if data_set[mid] == value: return mid elif data_set[mid] &gt; value: return bin_search_rec(data_set, value, low, mid - 1) else: return bin_search_rec(data_set, value, mid + 1, high) else: return None]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
